@startuml
title DRPC Framework Workflow

actor "Client App" as client
participant "RpcClient" as rpcClient
participant "JdkProxyFactory" as jdkProxyFactory
participant "ObjectProxy" as objectProxy
participant "RpcHeaderFactory" as headerFactory
participant "RpcConsumer" as rpcConsumer
participant "RpcConsumerHandler" as consumerHandler
participant "RpcEncoder" as encoder
participant "Netty Network" as network
participant "RpcDecoder" as decoder
participant "RpcProviderHandler" as providerHandler
participant "ServerThreadPool" as threadPool
participant "Service Bean" as serviceBean
participant "RpcSingleServer" as rpcServer
participant "RpcServiceScanner" as svcScanner

== Provider Startup Phase ==

rpcServer -> rpcServer : Initialize server\n(117.72.33.162:27880, scanPackage, reflectType)
rpcServer -> rpcServer : Initialize RegistryService\n(117.72.33.162:2181, zookeeper)
rpcServer -> svcScanner : Scan service package
svcScanner -> svcScanner : Find @RpcService classes
svcScanner -> svcScanner : Create service instances
svcScanner -> svcScanner : Build service key\n(interface#version#group)
svcScanner -> svcScanner : Register to Zookeeper\n(ServiceMeta: name, version, host, port, group)
svcScanner --> rpcServer : Return handlerMap
rpcServer -> rpcServer : Start Netty server\nPipeline: RpcDecoder\n-> RpcEncoder\n-> RpcProviderHandler

note right of rpcServer
  Provider ready at 117.72.33.162:27880
  Services registered to Zookeeper
  Waiting for connections
end note

== Client Invocation Phase ==

client -> rpcClient : Create RpcClient\n(117.72.33.162:2181, zookeeper,\nversion, group, serializationType,\ntimeout, async, oneway)
rpcClient -> rpcClient : Initialize RegistryService\n(117.72.33.162:2181, zookeeper)
rpcClient -> jdkProxyFactory : Create proxy factory
jdkProxyFactory -> objectProxy : Create ObjectProxy
jdkProxyFactory --> rpcClient : Return proxy
client -> objectProxy : Call service method\nservice.hello("World")

objectProxy -> objectProxy : Intercept method call
objectProxy -> headerFactory : Create RpcHeader
headerFactory --> objectProxy : Return header\n(magic, requestId, messageType)
objectProxy -> objectProxy : Build RpcRequest\n(className, methodName,\nparameterTypes, parameters)
objectProxy -> objectProxy : Wrap RpcProtocol<RpcRequest>

objectProxy -> rpcConsumer : sendRequest(protocol, registryService)
rpcConsumer -> rpcConsumer : Build service key\n(interface#version#group)
rpcConsumer -> rpcConsumer : Discover service from Zookeeper\n(get ServiceMeta with load balancing)
rpcConsumer -> rpcConsumer : Get/create connection to provider\n(117.72.33.162:27880, connection reuse)
rpcConsumer -> consumerHandler : Get RpcConsumerHandler

consumerHandler -> consumerHandler : Determine call mode\n(sync/async/oneway)
consumerHandler -> consumerHandler : Create RpcFuture\nStore in pendingRPC Map

consumerHandler -> encoder : Encode request
encoder -> encoder : Write protocol header\n(magic, messageType, status,\nrequestId, serializationType)
encoder -> encoder : Serialize message body
encoder -> network : Send byte stream

== Provider Processing Phase ==

network -> decoder : Receive byte stream
decoder -> decoder : Read protocol header\nValidate magic number
decoder -> decoder : Deserialize message body
decoder --> providerHandler : Pass RpcProtocol<RpcRequest>

providerHandler -> threadPool : Submit to thread pool
threadPool -> providerHandler : Async execution

providerHandler -> providerHandler : Build service key\n(className#version#group)
providerHandler -> providerHandler : Lookup service from handlerMap
providerHandler -> providerHandler : Get method info\n(methodName, parameterTypes)

alt JDK Reflection
  providerHandler -> serviceBean : method.invoke(serviceBean, parameters)
else CGLIB Reflection
  providerHandler -> serviceBean : FastMethod.invoke(serviceBean, parameters)
end

serviceBean --> providerHandler : Return result

providerHandler -> providerHandler : Build RpcResponse\n(result or error)
providerHandler -> providerHandler : Set response header\n(messageType=RESPONSE, status)
providerHandler -> encoder : Encode response

encoder -> encoder : Serialize response
encoder -> network : Send response bytes

== Client Response Phase ==

network -> decoder : Receive response bytes
decoder -> decoder : Decode response
decoder --> consumerHandler : Pass RpcProtocol<RpcResponse>

consumerHandler -> consumerHandler : Extract requestId
consumerHandler -> consumerHandler : Remove RpcFuture from pendingRPC
consumerHandler -> consumerHandler : Call rpcFuture.done(response)

alt Sync Call
  consumerHandler --> objectProxy : Release blocked Future.get()
  objectProxy --> client : Return result
else Async Call
  consumerHandler -> consumerHandler : Execute callback\n(AsyncRpcCallback)
  consumerHandler --> client : Return via callback
else Oneway Call
  note right of consumerHandler
    No response needed
    Return immediately
  end note
end

== Core Features ==

note over rpcClient, objectProxy
  **Client Components**
  - RpcClient: Entry point, config management
  - RegistryService: Service discovery from Zookeeper
  - JdkProxyFactory: Create JDK dynamic proxy
  - ObjectProxy: Intercept calls, convert to RPC
  - Support sync/async/oneway modes
end note

note over rpcConsumer, consumerHandler
  **Network Layer**
  - RpcConsumer: Singleton, connection pool
  - Service discovery via RegistryService
  - Load balancing (Random/RoundRobin/ConsistentHash)
  - RpcConsumerHandler: Request-response matching
  - Connection reuse mechanism
  - Precise matching via requestId
end note

note over encoder, decoder
  **Codec Layer**
  - Custom binary protocol
  - Fixed 32-byte header
  - Multiple serialization support
  - Magic Number: 0x10
end note

note over providerHandler, serviceBean
  **Provider Processing**
  - Thread pool async processing
  - JDK/CGLIB reflection support
  - Service identified by interface#version#group
  - Auto-scan @RpcService annotations
end note

note over rpcServer, svcScanner
  **Service Registry**
  - Scan packages on startup
  - Auto-register to Zookeeper (117.72.33.162:2181)
  - Register to local handlerMap
  - Service grouping and versioning
  - ServiceMeta: name, version, host, port, group
  - High-performance Netty server
end note

@enduml